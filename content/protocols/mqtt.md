# 白话消息队列遥测传输协议（MQTT）

MQTT 是一种基于发布/订阅模式的轻量级通讯协议，该协议构建于 TCP/IP 协议上，由 IBM 在 1999 年发布，它是开放消息协议，简单容易实现，消息支持 Qos。MQTT 最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。这些特性，使其在物联网、小型设备、移动应用、车联网、电力能源等方面有着较为广泛的应用。

MQTT 最初是由 AndyStandford-Clark 博士和 Arlen Nipper 博士于 1999 年发明的通讯协议。他们当时是为了在狭窄的网络带宽和微小电力损耗的前提之下，提供石油管道传感器和人造卫星之间一个轻量、可靠的二进制通讯协议。2011 年，IBM 和 Eurotech 将 MQTT 协议捐赠给 Eclipse 基金会，并加入了 Eclipse M2M Industry 工作组织。2014 年 10 月，MQTT 正式成为一个开放的 OASIS 国际标准。

MQTT 具有如下特点：

- 轻量可靠：MQTT 报文格式精简、紧凑，可在严重受限的硬件设备和低带宽、高延迟的网络上实现稳定传输。
- 发布订阅模式：可以使发布者与订阅者解耦，实现异步协议，即订阅者和发布者不需要建立直接连接、也不需要同时在线。
- 为物联网而生：提供心跳机制、遗嘱消息、Qos 质量等级+离线消息、主题和安全管理，符合物联网应用特性。
- 生态日趋完善：实现多语言平台客户端和 SDK，多家云厂商支持并提供 IOT 服务，多种嵌入式硬件支持。

先说下 MQTT 轻量可靠是怎么做到的？

MQTT 基于 TCP/IP，TCP/IP 是一种面向连接的、可靠的、基于字节流的通信协议。我这两天一直看的是 MQTT3.1.1 协议，就以它来讲。MQTT 包含 14 种类型的控制包，应用之间的交互就是通过这 14 种包协作来完成。这些控制包有固定的结构，分为 3 部分：固定包头，可变包头，载荷。

这里处处都是精华，我们来细看：

固定包头占用 2 个字节，每一个控制包都包含。第一个字节高四位，指示控制包类型。低四位是每个 MQTT 控制包类型的特殊标识。第二个字节用来指示控制包的剩余字节长度，包括可变包头的数据以及载荷。剩余长度不包含用来编码剩余长度的字节。它使用了一种可变长度结构来编码。我在此处费了一些脑细胞，我用白话来讲解下这段，我们知道一个字节一共有 8 位，可以表示十进制 256，现在，这个字节中的第 8 位用来表示是否还有下一个字节，剩下 7 位来表示长度，可以表示十进制 128。MQTT 规定，剩余长度最多可以用四个字节来表示。也就是允许这个控制包最大的长度为 256M 大小。协议给出了编码算法和解码算法，可以看 MQTT 官方协议。

我这里拿十进制 321 来举例进行编码。你要记住，这个算法的精髓是逢 128 进位。我们将 321 整除 128 求余数，得余数 65，放在第一个字节，然后将 321 整除 128 求商，得商为 2，当为 0 时截止，因为此时商为 2，说明还有下一个字节，我们需要将第一个字节的第 8 位置 1，在计算机中，将某一位置 1，可以使用或计算。这里是将 65 和 128 的二进制进行或运算。我们来计算下一个字节，将得到的商 2，继续整除 128 求余数，得余数 2，放在第二个字节，然后将 2 整除 128 求商，得商为 0，停止计算。最后得出的结果是，第一个字节 65+128=193，第二个字节是 2。然后我们再看下上面的结果如何再解码出长度数据。我们首先对第一个字节和十进制 127（01111111）进行与运算，这一步是取出 7 位实际数据，然后乘以算法因子（算法因子是 1*128*128\*128，即第一个字节乘 1，第二个到第四个都是乘以 128，因为是 128 进位）。得出第一个字节的值为 65，然后将第一个字节和十进制 128（10000000）进行与运算，可以算出第 8 位是否为 1，如果为 1，说明还有下一个字节。然后将第二个字节和十进制 127 进行与运算，得出 2，然后乘以 128，得出的结果 256 和第一个字节 65 相加，得出 321。然后再将第二个字节和十进制 128 进行与运算，查看第 8 位是否为 1，可以知道，这里为 0，停止运算，结果就是 321。

固定包头讲完了，我们看看可变包头，当时我在想，写到载荷中不行吗？非得加可变包头，深度思考后我个人是这样想的，可变包头是协议定义的，载荷是用户提交的数据，意义不一样。协议中定义那么在实现 SDK 或功能时，必须实现，而最终使用者可以不关心这个，这个是我的理解。可变包头不是每个控制包都包含，MQTT 定义了有哪些控制包必须包含，例如订阅，发布，取消订阅。可变包头的内容取决于包的类型。很多类型的控制包的可变包头都包含了 2 字节的唯一标识字段。它用来唯一识别这个控制包，确保服务质量可靠性。

载荷存在于一些控制包类型中。MQTT 定义了有哪些控制包必须包含载荷，载荷可以存放应用消息，是应用提交的数据。如果用有用功来表示的话，这部分数据对于应用来说才是有用功。

在前面介绍我入门 TCP 后的问题中，我提到了需要自定义数据格式，这里 MQTT 规定了数据格式，并且设计的非常精妙，完美解决数据格式问题。那么它是如何解决认证问题呢？MQTT 在 CONNECT 控制包中，可变包头中指定了连接标识，当 UserNameFlag 设置为 1 时，用户名必须出现在载荷中，当 PasswordFlag 设置为 1 时，密码必须出现在载荷中。这样在协议中就解决了认证问题，不依赖服务器 IP 白名单。

最后，再来说说质量服务 Qos，这个也是核心精髓，MQTT 根据质量服务等级来分发应用消息。Qos 分为 3 个等级：Qos0，最多分发一次，Qos1，最少分发一次，Qos2，精确一次分发。随着服务质量提高，会增加相应的开销。

在 Qos0 等级下，消息只发送一次，不管接收者是否收到。我们看下流程图：

| 发送者               | 控制包  | 接收者                 |
| -------------------- | ------- | ---------------------- |
| PUBLISH Qos 0，DUP=0 | ------> | 分发消息给合适的接收者 |

在 Qos1 等级下，确保消息至少一次抵达接收者。Qos1 中的 PUBLISH 包的可变包头中包含唯一标识，而且有 PUBACK 包确认。我们看下流程图：

| 发送者                                   | 控制包  | 接收者                 |
| ---------------------------------------- | ------- | ---------------------- |
| 存储消息，PUBLISH Qos 1,DUP 0,包唯一标识 | ------> | 接收并转发消息         |
| 销毁消息                                 | <------ | 发送 PUBACK 包唯一标识 |

在 Qos2 等级下，确保消息精确一次分发，不能丢失不能重复。这种服务质量会增加开销。Qos2 消息可变包头中包含唯一标识。Qos2 的 PUBLISH 包的接收者分两步确认接收。我们看下流程图：

| 发送者                                   | 控制包  | 接收者                     |
| ---------------------------------------- | ------- | -------------------------- |
| 存储消息，PUBLISH Qos 2,DUP 0,包唯一标识 | ------> | 方法 A，存储消息           |
| 销毁消息，存储 PUBREC 包                 | <------ | PUBREC 包唯一标识          |
| PUBREL 包唯一标识                        | ------> | 方法 A，转发消息并销毁消息 |
| 销毁存储状态                             | <------ | PUBCOMP 包唯一标识         |

为什么 Qos2 消息不会重复？与 Qos1 相比，Qos2 增加了 PUBREL 报文和 PUBCOMP 报文，在使用 Qos1 消息时，对接收方来说，回复完 PUBACK 报文后，Packet ID 就可以重新使用了，也不管是否确实发送到了发送方。这样，当收到相同 Packet ID 报文后，无法得知时发送方因为没有收到响应而重传，还是发送方收到了响应而重新使用 Packet ID，发送了一个全新的消息。所以，消息去重的关键就在于，通信双方如何正确的同步释放 Packet ID。在 Qos2 中增加的 PUBREL 流程，就是帮助通信双方 Packet ID 何时重用的能力。Qos2 规定，发送方只有收到 PUBREC 报文之前可以重传 PUBLISH 报文。一旦收到 PUBREC 报文并发出 PUBREL 报文，发送方就进入了 Packet ID 释放流程，不可以再使用当前 PacketID 重传 PUBLISH 报文。同时，在收到对端回复的 PUBCOMP 报文确认双方都完成 Packet ID 释放之前，也不可以使用当前 Packet ID 发送新的消息。

MQTT 通过 Qos 保证了消息可靠性。最后，我们来说说发布订阅，这也是一个亮点。我们假设没有发布订阅，那么发送者和接受者需要直接连接，或者通过中转器，无论哪一种，发送者个接受者都绑定到了一起。

MQTT 的遗嘱消息，这里也聊一下。在 MQTT 协议中，遗嘱的建立是发布者在连接的时候就确定了的，当连接到 Broker 时，连接的遗嘱标识会设置，遗嘱信息，遗嘱主题以及遗嘱 Qos 等信息会放在载荷中。当这个客户端没有发送 DISCONNECT 控制包，就断开了连接，那么 Broker 要将遗嘱消息分发给订阅了遗嘱主题的客户端。这个遗嘱消息常用来监控客户端非正常断开连接。这里依石油管道传感器举例，在真实环境中，传感器可能突然断开连接，在非正常断开的时候，Broker 会将遗嘱消息发给订阅者，这样管理人员能够知道是哪个传感器出了问题，方便下一步操作。

更多的内容，请参考官方文档。

https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html
